// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'plugin_man.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `plugin_file_validity`, `read_plugin_metadata`, `rpc2plugin`, `valid_extension`, `valid_magic`, `valid_stem`, `validate_and_filter_fad_config`, `validate_rpc`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `PluginManErr`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `call_func_plugins`, `call_plugin_func`, `find_buttons_by_name`, `find_items_by_callback`, `get_all_buttons`, `get_all_popups`, `get_all_screens`, `get_plugin_config`, `get_plugin_fad_config`, `get_plugin_meta`, `load_plugin`, `new`, `reload_plugin`, `remove_plugin`, `scan_dir`, `set_plugin_config`

Future<void> initPluginMan() =>
    RustLib.instance.api.crateApiPluginManInitPluginMan();

Future<bool> checkPluginMan({AdiPluginMan? pmg}) =>
    RustLib.instance.api.crateApiPluginManCheckPluginMan(pmg: pmg);

Future<String> loadPlugin({required String path}) =>
    RustLib.instance.api.crateApiPluginManLoadPlugin(path: path);

Future<String> removePlugin({required String path}) =>
    RustLib.instance.api.crateApiPluginManRemovePlugin(path: path);

Future<String> getPluginConfig({required String path}) =>
    RustLib.instance.api.crateApiPluginManGetPluginConfig(path: path);

Future<List<String>?> scanDir({required String path}) =>
    RustLib.instance.api.crateApiPluginManScanDir(path: path);

Future<String> reloadPlugin({required String path}) =>
    RustLib.instance.api.crateApiPluginManReloadPlugin(path: path);

Future<bool> isPluginLoaded({required String path}) =>
    RustLib.instance.api.crateApiPluginManIsPluginLoaded(path: path);

Future<List<String>> listLoadedPlugins() =>
    RustLib.instance.api.crateApiPluginManListLoadedPlugins();

Future<String> setPluginConfig(
        {required String path,
        required String key,
        required ConfigTypes value}) =>
    RustLib.instance.api
        .crateApiPluginManSetPluginConfig(path: path, key: key, value: value);

Future<void> callFuncPlugins({required String func}) =>
    RustLib.instance.api.crateApiPluginManCallFuncPlugins(func: func);

Future<void> callPluginFunc({required String func, required String plugin}) =>
    RustLib.instance.api
        .crateApiPluginManCallPluginFunc(func: func, plugin: plugin);

Future<String> getAllButtons({String? locationFilter}) => RustLib.instance.api
    .crateApiPluginManGetAllButtons(locationFilter: locationFilter);

Future<String> getAllScreens() =>
    RustLib.instance.api.crateApiPluginManGetAllScreens();

Future<String> getAllPopups() =>
    RustLib.instance.api.crateApiPluginManGetAllPopups();

Future<String> getPluginFadConfig({required String path}) =>
    RustLib.instance.api.crateApiPluginManGetPluginFadConfig(path: path);

Future<String> findButtonsByName({required String name}) =>
    RustLib.instance.api.crateApiPluginManFindButtonsByName(name: name);

Future<String> findItemsByCallback({required String callback}) =>
    RustLib.instance.api
        .crateApiPluginManFindItemsByCallback(callback: callback);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PluginInode>>
abstract class PluginInode implements RustOpaqueInterface {
  Map<String, ConfigTypes> get config;

  FadConfig? get fad;

  ArcMutexPlugin get plugin;

  set config(Map<String, ConfigTypes> config);

  set fad(FadConfig? fad);

  set plugin(ArcMutexPlugin plugin);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RpcConfig>>
abstract class RpcConfig implements RustOpaqueInterface {
  String get ctype;

  Value get defaultVal;

  String get key;

  Value get setVal;

  set ctype(String ctype);

  set defaultVal(Value defaultVal);

  set key(String key);

  set setVal(Value setVal);
}

class AdiPluginMan {
  final Map<String, PluginInode> pluginMeta;

  const AdiPluginMan({
    required this.pluginMeta,
  });

  @override
  int get hashCode => pluginMeta.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AdiPluginMan &&
          runtimeType == other.runtimeType &&
          pluginMeta == other.pluginMeta;
}

@freezed
sealed class ConfigTypes with _$ConfigTypes {
  const ConfigTypes._();

  const factory ConfigTypes.string(
    String field0,
  ) = ConfigTypes_String;
  const factory ConfigTypes.bool(
    bool field0,
  ) = ConfigTypes_Bool;
  const factory ConfigTypes.int(
    int field0,
  ) = ConfigTypes_Int;
  const factory ConfigTypes.uInt(
    int field0,
  ) = ConfigTypes_UInt;
  const factory ConfigTypes.bigInt(
    BigInt field0,
  ) = ConfigTypes_BigInt;
  const factory ConfigTypes.bigUInt(
    BigInt field0,
  ) = ConfigTypes_BigUInt;
  const factory ConfigTypes.float(
    double field0,
  ) = ConfigTypes_Float;
}

class FadButton {
  final String name;
  final String? icon;
  final String? location;
  final String callback;

  const FadButton({
    required this.name,
    this.icon,
    this.location,
    required this.callback,
  });

  Future<bool> isValid() =>
      RustLib.instance.api.crateApiPluginManFadButtonIsValid(
        that: this,
      );

  @override
  int get hashCode =>
      name.hashCode ^ icon.hashCode ^ location.hashCode ^ callback.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FadButton &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          icon == other.icon &&
          location == other.location &&
          callback == other.callback;
}

class FadConfig {
  final List<FadScreen>? screens;
  final List<FadPopup>? popups;
  final List<FadButton>? buttons;

  const FadConfig({
    this.screens,
    this.popups,
    this.buttons,
  });

  @override
  int get hashCode => screens.hashCode ^ popups.hashCode ^ buttons.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FadConfig &&
          runtimeType == other.runtimeType &&
          screens == other.screens &&
          popups == other.popups &&
          buttons == other.buttons;
}

class FadLabel {
  final double size;
  final String text;
  final String? color;

  const FadLabel({
    required this.size,
    required this.text,
    this.color,
  });

  @override
  int get hashCode => size.hashCode ^ text.hashCode ^ color.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FadLabel &&
          runtimeType == other.runtimeType &&
          size == other.size &&
          text == other.text &&
          color == other.color;
}

class FadPopup {
  final List<FadButton>? buttons;
  final List<FadLabel>? labels;

  const FadPopup({
    this.buttons,
    this.labels,
  });

  @override
  int get hashCode => buttons.hashCode ^ labels.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FadPopup &&
          runtimeType == other.runtimeType &&
          buttons == other.buttons &&
          labels == other.labels;
}

class FadScreen {
  final List<FadButton>? buttons;
  final List<FadLabel>? labels;

  const FadScreen({
    this.buttons,
    this.labels,
  });

  @override
  int get hashCode => buttons.hashCode ^ labels.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FadScreen &&
          runtimeType == other.runtimeType &&
          buttons == other.buttons &&
          labels == other.labels;
}
