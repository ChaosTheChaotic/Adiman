// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `background_worker`, `crossfade`, `extract_metadata`, `get_cached_mp3_path`, `get_mp3_cache_dir`, `get_position`, `new`, `pause`, `play`, `resume`, `seek`, `stop`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `AudioChunk`, `AudioPlayer`, `PlayerMessage`, `StreamWrapper`, `StreamingBuffer`, `StreamingSource`, `Track`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `channels`, `clone`, `clone`, `clone`, `current_frame_len`, `fmt`, `fmt`, `fmt`, `fmt`, `next`, `sample_rate`, `total_duration`

bool initializePlayer() =>
    RustLib.instance.api.crateApiMusicHandlerInitializePlayer();

List<SongMetadata> scanMusicDirectory(
        {required String dirPath, required bool autoConvert}) =>
    RustLib.instance.api.crateApiMusicHandlerScanMusicDirectory(
        dirPath: dirPath, autoConvert: autoConvert);

bool playSong({required String path}) =>
    RustLib.instance.api.crateApiMusicHandlerPlaySong(path: path);

bool pauseSong() => RustLib.instance.api.crateApiMusicHandlerPauseSong();

bool resumeSong() => RustLib.instance.api.crateApiMusicHandlerResumeSong();

bool stopSong() => RustLib.instance.api.crateApiMusicHandlerStopSong();

double getPlaybackPosition() =>
    RustLib.instance.api.crateApiMusicHandlerGetPlaybackPosition();

bool seekToPosition({required double position}) =>
    RustLib.instance.api.crateApiMusicHandlerSeekToPosition(position: position);

bool skipToNext({required List<String> songs, required BigInt currentIndex}) =>
    RustLib.instance.api.crateApiMusicHandlerSkipToNext(
        songs: songs, currentIndex: currentIndex);

bool skipToPrevious(
        {required List<String> songs, required BigInt currentIndex}) =>
    RustLib.instance.api.crateApiMusicHandlerSkipToPrevious(
        songs: songs, currentIndex: currentIndex);

String? getCachedAlbumArt({required String path}) =>
    RustLib.instance.api.crateApiMusicHandlerGetCachedAlbumArt(path: path);

String? getCurrentSongPath() =>
    RustLib.instance.api.crateApiMusicHandlerGetCurrentSongPath();

Float32List getRealtimePeaks() =>
    RustLib.instance.api.crateApiMusicHandlerGetRealtimePeaks();

bool isPlaying() => RustLib.instance.api.crateApiMusicHandlerIsPlaying();

/// Extracts waveform data from an MP3 file using FFmpeg to decode it to PCM data.
///
/// This function launches FFmpeg with arguments to decode [mp3_path] to 16-bit PCM (s16le)
/// using the given number of [channels] (default is 2). It then downsamples the resulting PCM
/// stream to return [sampleCount] normalized amplitude values (between 0 and 1).
///
/// Note: This requires FFmpeg to be installed on your Linux system.
Float64List extractWaveformFromMp3(
        {required String mp3Path, int? sampleCount, int? channels}) =>
    RustLib.instance.api.crateApiMusicHandlerExtractWaveformFromMp3(
        mp3Path: mp3Path, sampleCount: sampleCount, channels: channels);

void addSeparator({required String separator}) =>
    RustLib.instance.api.crateApiMusicHandlerAddSeparator(separator: separator);

void removeSeparator({required String separator}) => RustLib.instance.api
    .crateApiMusicHandlerRemoveSeparator(separator: separator);

List<String> getCurrentSeparators() =>
    RustLib.instance.api.crateApiMusicHandlerGetCurrentSeparators();

void resetSeparators() =>
    RustLib.instance.api.crateApiMusicHandlerResetSeparators();

void setSeparators({required List<String> separators}) => RustLib.instance.api
    .crateApiMusicHandlerSetSeparators(separators: separators);

Future<String> downloadToTemp({required String query}) =>
    RustLib.instance.api.crateApiMusicHandlerDownloadToTemp(query: query);

Future<void> cancelDownload() =>
    RustLib.instance.api.crateApiMusicHandlerCancelDownload();

bool clearMp3Cache() =>
    RustLib.instance.api.crateApiMusicHandlerClearMp3Cache();

List<String> getArtistViaFfprobe({required String filePath}) =>
    RustLib.instance.api
        .crateApiMusicHandlerGetArtistViaFfprobe(filePath: filePath);

class PlayerState {
  final bool initialized;

  const PlayerState({
    required this.initialized,
  });

  static Future<PlayerState> default_() =>
      RustLib.instance.api.crateApiMusicHandlerPlayerStateDefault();

  @override
  int get hashCode => initialized.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PlayerState &&
          runtimeType == other.runtimeType &&
          initialized == other.initialized;
}

class SongMetadata {
  final String title;
  final String artist;
  final String album;
  final BigInt duration;
  final String path;
  final String? albumArt;
  final String genre;

  const SongMetadata({
    required this.title,
    required this.artist,
    required this.album,
    required this.duration,
    required this.path,
    this.albumArt,
    required this.genre,
  });

  @override
  int get hashCode =>
      title.hashCode ^
      artist.hashCode ^
      album.hashCode ^
      duration.hashCode ^
      path.hashCode ^
      albumArt.hashCode ^
      genre.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SongMetadata &&
          runtimeType == other.runtimeType &&
          title == other.title &&
          artist == other.artist &&
          album == other.album &&
          duration == other.duration &&
          path == other.path &&
          albumArt == other.albumArt &&
          genre == other.genre;
}
